#include "stepper.h"
#include <math.h>
#include <stdio.h>

#define GROUP_SIZE 10  // Steps per group (adjust as needed)
#define PIO_INTR_SM0_TXNEMPTY 0     // PIO interrupt source for SM0 TX FIFO empty
#define PIO_INTR_IRQ0 8             // PIO interrupt source for 'irq 0' instruction

#define CYCLES_PER_STEP 63.0         // Number of PIO clock cycles per step pulse

#define INTERVAL_MS 10
#define MIN_GROUP_STEPS 10
#define MIN_FREQ 40.0f              // Frecuencia mínima de seguridad

STEPPER_DRV *s1, *s2, *s3, *s4;     // Pointers to each stepper motor driver

uint8_t steper_number = 0;         // Counter to assign PIO state machines
uint stm_offset;                   // Offset of the loaded PIO program

bool flag = 0;                     // Used to ensure PIO program is only loaded once




void setupStepper(STEPPER_DRV * stepper, uint8_t enable_pin, uint8_t dir_pin, uint8_t step_pin){
    if(steper_number > 3){
        printf("Error: No available stepper slots\n");
        return;
    }

    // Default configuration
    stepper->StepsToTake = 0;
    stepper->activedir = true;
    stepper->dir = RIGHT;
    stepper->ActiveAngle = 0.0;
    stepper->directionchangeDelayCounter = 0;
    stepper->stm_pio = pio0;
    stepper->stm_sm = steper_number;  // Assign state machine 0–3
    stepper->ENABLE_PIN = enable_pin;
    stepper->DIR_PIN = dir_pin;
    stepper->STEP_PIN = step_pin;
    stepper->FULLSTEP = 800;          // Default step resolution

    // Store pointer to global variable depending on index
    switch (steper_number){
        case 0: s1 = stepper; break;
        case 1: s2 = stepper; break;
        case 2: s3 = stepper; break;
        case 3: s4 = stepper; break;
        default: break;
    }

    steper_number++;                // Increment the SM counter

    setupGPIO(stepper);            // Initialize GPIOs
    setupPIO(stepper);            // Configure the PIO for this motor
}



void setupPIO(STEPPER_DRV * stepper)
{
    if(flag == 0){
        // Load PIO program only once and assign IRQ handler
        stm_offset = pio_add_program(stepper->stm_pio, &stepper_precise_program);
        irq_set_exclusive_handler(PIO0_IRQ_0, pio0_irq0_handler);
        irq_set_enabled(PIO0_IRQ_0, true);

        // Enable PIO interrupt generated by the 'irq 0' instruction
        pio_set_irq0_source_enabled(pio0, PIO_INTR_IRQ0, true);
        flag++;
    }

    printf("Setup IO SM: %d\n ", stepper->stm_sm);

    // Initialize the PIO state machine with program, frequency, pin
    stepper_1_program_init(stepper->stm_pio, stepper->stm_sm, stm_offset, stepper->STEP_PIN, 1000, true);

    // Enable PIO interrupt for this SM
    pio_set_irq0_source_enabled(pio0, (enum pio_interrupt_source)(PIO_INTR_IRQ0 + stepper->stm_sm), true);
}




void setupGPIO(STEPPER_DRV * stepper)
{

    // stepper enable pin
    gpio_init(stepper->ENABLE_PIN);
    gpio_set_dir(stepper->ENABLE_PIN, GPIO_OUT);

    // stepper STEP pin
    gpio_init(stepper->STEP_PIN);
    gpio_set_dir(stepper->STEP_PIN, GPIO_OUT);

    // stepperMotor1 dir pin
    gpio_init(stepper->DIR_PIN);
    gpio_set_dir(stepper->DIR_PIN, GPIO_OUT);
    // gpio_put(stepperMotor1.DIR_PIN, 1);

}

// Handler de interrupción para pio0
void pio0_irq0_handler() {
    
     uint32_t irq_status = pio0->irq;         // Read active IRQ flags
    pio_interrupt_clear(pio0, 0);            // Clear IRQ0 so we can trigger it again

    printf("%b\n", irq_status);
    // Check which state machine caused the interrupt
    if (irq_status & (1 << 0)) {
        printf("Interrupción de SM0\n");
        startNextMove(s1);
    }
    if (irq_status & (1 << 1)) {
        printf("Interrupción de SM1\n");
        startNextMove(s2);
    }
    if (irq_status & (1 << 2)) {
        printf("Interrupción de SM2\n");
        startNextMove(s3);
    }
    if (irq_status & (1 << 3)) {
        printf("Interrupción de SM3\n");
        startNextMove(s4);
    }
   

    pio0->irq = irq_status;  // Clear any remaining bits
    printf("Stepper done!\n");
    
}


void setFrec( STEPPER_DRV * stepper, float desired_freq){
    float new_div = clock_get_hz(clk_sys) / (desired_freq*CYCLES_PER_STEP);
    pio_sm_set_clkdiv(stepper->stm_pio, stepper->stm_sm , new_div);
}

void setDirection( STEPPER_DRV * stepper,int direction){
    switch (direction)
    {
    case -1:
        stepper->dir = LEFT;
        gpio_put(stepper->DIR_PIN, false);
        break;
    case 1:
        stepper->dir = RIGHT;
        gpio_put(stepper->DIR_PIN, true);
        break;
    default:
     printf("DIRECTION ERROR\n");
        break;
    }
}

void moveSteps(STEPPER_DRV * stepper, int steps ){
    if(steps == 0){
        printf("STEPS MUST BE DIFFERENT THAN ZERO\n");
        return;
    }

    // Set direction based on sign
    if(steps > 0){
        setDirection(stepper, RIGHT);
    } else {
        setDirection(stepper, LEFT);
    }

    // Enable stepper driver
    gpio_put(stepper->ENABLE_PIN, false);

    // Send number of steps to PIO
    pio_sm_put_blocking(stepper->stm_pio, stepper->stm_sm , abs(steps));
}



void moveStepsAtSpeed(STEPPER_DRV * stepper, int steps, float frec){
    setFrec(stepper, frec);
    moveSteps(stepper, steps);
}

void enqueueMovement(STEPPER_DRV* stepper, int steps, int freq) {
    if (stepper->buffer_length >= BUFFER_SIZE) {
        printf("Buffer full for SM%d\n", stepper->stm_sm);
        return;
    }

    int i = stepper->buffer_tail;

    stepper->buffer[i].steps = steps;
    stepper->buffer[i].freq = freq;

    stepper->buffer_tail = (stepper->buffer_tail + 1) % BUFFER_SIZE;
    stepper->buffer_length++;

    // If stepper is idle, start moving immediately
    if (!stepper->running) {
        stepper->running = true;
        startNextMove(stepper);
    }
}


void startNextMove(STEPPER_DRV* stepper) {
       if (stepper->buffer_length == 0) {
        stepper->running = false;
        printf("END\n");
        return;
    }

    int i = stepper->buffer_head;
    printf("Queue number: %d\n", i);
    int steps = stepper->buffer[i].steps; 
    int freq  = stepper->buffer[i].freq;

    moveStepsAtSpeed(stepper, steps, freq);

    stepper->buffer_head ++;
    if(stepper->buffer_head  >= BUFFER_SIZE){
        stepper->buffer_head  = 0;
    }
    
    stepper->buffer_length--;
}



void generateSmoothSpeedRamp(STEPPER_DRV *stepper, float f_start, float f_end, float accel) {
    float delta_f = f_end - f_start;
    if (delta_f == 0.0f) return;

    float sign = (delta_f > 0) ? 1.0f : -1.0f;
    float t_total = fabsf(delta_f) / accel;

    float accumulated_steps = 0.0f;
    float accumulated_time_ms = 0.0f;

    for (int t_ms = 0; t_ms < (int)(t_total * 1000); t_ms += INTERVAL_MS) {
        float t = t_ms / 1000.0f;

        // Lineal:
        // float freq = f_start + sign * accel * t;

        // S-curve:
        float s_curve = 0.5f - 0.5f * cosf(M_PI * t / t_total);
        float freq = f_start + (f_end - f_start) * s_curve;

        float delta_steps = freq * (INTERVAL_MS / 1000.0f);
        accumulated_steps += delta_steps;
        accumulated_time_ms += INTERVAL_MS;

        if (accumulated_steps >= MIN_GROUP_STEPS) {
            int steps_to_send = (int)accumulated_steps;
            float avg_freq = accumulated_steps / (accumulated_time_ms / 1000.0f);
            if (avg_freq < MIN_FREQ) avg_freq = MIN_FREQ;

            enqueueMovement(stepper, steps_to_send, avg_freq);
            accumulated_steps -= steps_to_send;
            accumulated_time_ms = 0;
        }
    }

    // Actualizamos velocidad actual del stepper
    stepper->actual_speed = f_end;
}


uint8_t generateAccelerationRamp(STEPPER_DRV *stepper, float t_accel, float v_start, float accel) {
    float accumulated_steps = 0.0f;
    float accumulated_time_ms = 0.0f;

    for (int i = 0; i < (int)(t_accel * 1000); i += INTERVAL_MS) {
        float t = i / 1000.0f; // tiempo en segundos

        // Frecuencia en este instante
        float freq = v_start + accel * t;
        if (freq < MIN_FREQ) freq = MIN_FREQ;

        // Calcula los pasos que corresponden a este intervalo
        float delta_steps = freq * (INTERVAL_MS / 1000.0f);
        accumulated_steps += delta_steps;
        accumulated_time_ms += INTERVAL_MS;

        // Cuando tenemos un grupo mínimo de pasos, enviamos el movimiento
        if (accumulated_steps >= MIN_GROUP_STEPS) {
            int steps_to_send = (int)accumulated_steps;
            float avg_freq = accumulated_steps / (accumulated_time_ms / 1000.0f);
            if (avg_freq < MIN_FREQ) avg_freq = MIN_FREQ;

            enqueueMovement(stepper, steps_to_send, avg_freq);

            // Restamos los pasos enviados y reiniciamos el contador de tiempo acumulado
            accumulated_steps -= steps_to_send;
            accumulated_time_ms = 0;
        }
    }

    // Por si quedan pasos residuales tras el bucle
    return accumulated_steps;
}


uint8_t generateSmoothAccelerationRamp(STEPPER_DRV *stepper, float t_accel, float v_start, float accel) {

    float accumulated_steps = 0.0f;
    float accumulated_time_ms = 0.0f;
    float v_max = v_start + accel * t_accel;

    for (int i = 0; i < (int)(t_accel * 1000); i += INTERVAL_MS) {
        float t = i / (t_accel * 1000.0f); // [0,1]
        float s_curve = 0.5f - 0.5f * cosf(M_PI * t); // Ease-in S-curve

        float freq = v_start + (v_max - v_start) * s_curve;
        // Frecuencia en este instante
    
        if (freq < MIN_FREQ) freq = MIN_FREQ;

        // Calcula los pasos que corresponden a este intervalo
        float delta_steps = freq * (INTERVAL_MS / 1000.0f);
        accumulated_steps += delta_steps;
        accumulated_time_ms += INTERVAL_MS;

        // Cuando tenemos un grupo mínimo de pasos, enviamos el movimiento
        if (accumulated_steps >= MIN_GROUP_STEPS) {
            int steps_to_send = (int)accumulated_steps;
            float avg_freq = accumulated_steps / (accumulated_time_ms / 1000.0f);
            if (avg_freq < MIN_FREQ) avg_freq = MIN_FREQ;

            enqueueMovement(stepper, steps_to_send, avg_freq);

            // Restamos los pasos enviados y reiniciamos el contador de tiempo acumulado
            accumulated_steps -= steps_to_send;
            accumulated_time_ms = 0;
        }
    }

    // Por si quedan pasos residuales tras el bucle
    return accumulated_steps;
}

// Generates a trapezoidal velocity profile for a stepper motor movement
// total_steps: total number of steps to move
// v_start: initial velocity in steps/s
// v_max: maximum velocity in steps/s
// v_end: final velocity in steps/s
// accel: acceleration (and deceleration) in steps/s^2

float accumulated_steps = 0.0f;
int step_counter = 0;
int accumulated_time_ms = 0;

void generateTrapezoidalProfile(STEPPER_DRV *stepper, int total_steps, float v_start, float v_max, float v_end, float accel) {
    // --- Compute acceleration and deceleration times and step counts ---
    // Tiempo y pasos durante la aceleración
    float t_accel      = (v_max - v_start) / accel;                          // Tiempo para acelerar de v_start a v_max
    float steps_accel  = 0.5f * (v_start + v_max) * t_accel;                // Área bajo la curva de aceleración (trapezoide)

    // Tiempo y pasos durante la deceleración
    float t_decel      = (v_max - v_end) / accel;                            // Tiempo para desacelerar de v_max a v_end
    float steps_decel  = 0.5f * (v_max + v_end) * t_decel;                  // Área bajo la curva de deceleración

    // Pasos y tiempo a velocidad constante
    float steps_const  = total_steps - steps_accel - steps_decel;          // Resto de pasos a velocidad constante
    float t_const = 0.0f;
    if (steps_const > 0.0f) {
        t_const = steps_const / v_max;
    }

    // Tiempo total del perfil
    float total_time   = t_accel + t_const + t_decel;
        printf("Accel: %.1f steps | Const: %.1f steps | Decel: %.1f steps | Total Time: %.3f s\n", steps_accel, steps_const, steps_decel, total_time);

        // --- Handle triangular profile case (not implemented yet) ---
        if (steps_const < 0) {
                // --- PERFIL TRIANGULAR ---
            float v_peak_sq = accel * total_steps + 0.5f * (v_start * v_start + v_end * v_end);
            float v_peak = sqrtf(v_peak_sq);

            t_accel = (v_peak - v_start) / accel;
            steps_accel = 0.5f * (v_start + v_peak) * t_accel;

            t_decel = (v_peak - v_end) / accel;
            steps_decel = 0.5f * (v_peak + v_end) * t_decel;

            t_const = 0;
            v_max = v_peak;
            
        }

        // --- ACCELERATION PHASE ---
        generateAccelerationRamp(stepper,t_accel,v_start,accel);
        // --- CONSTANT SPEED PHASE ---
        if (steps_const >= 1.0f) {
            int steps_to_send = (int)steps_const;
            enqueueMovement(stepper, steps_to_send, v_max);
        }
         // --- DECELERATION PHASE ---
        generateAccelerationRamp(stepper,t_decel,v_max,-accel);
}


void  generateSmoothSProfile(STEPPER_DRV *stepper, int total_steps, float v_start, float v_max, float v_end, float accel) {
    // Calcula tiempos de aceleración/desaceleración con aceleración media
    float t_accel = (v_max - v_start) / accel;
    float t_decel = (v_max - v_end) / accel;

    // Estimación de pasos durante aceleración y desaceleración usando promedio
    float steps_accel = (v_start + v_max) / 2 * t_accel;
    float steps_decel = (v_max + v_end) / 2 * t_decel;

    float steps_const  = total_steps - steps_accel - steps_decel;          // Resto de pasos a velocidad constante
    float t_const = 0.0f;
    if (steps_const > 0.0f) {
        t_const = steps_const / v_max;
    }
    if (steps_const < 0) {
        // --- PERFIL TRIANGULAR ---
        float v_peak_sq = accel * total_steps + 0.5f * (v_start * v_start + v_end * v_end);
        float v_peak = sqrtf(v_peak_sq);

        t_accel = (v_peak - v_start) / accel;
        steps_accel = 0.5f * (v_start + v_peak) * t_accel;

        t_decel = (v_peak - v_end) / accel;
        steps_decel = 0.5f * (v_peak + v_end) * t_decel;

        t_const = 0;
        v_max = v_peak;
    }

    float accumulated_steps = 0.0f;
    float accumulated_time_ms = 0.0f;

    // --- ACCELERACIÓN SUAVIZADA ---
    int steps = generateSmoothAccelerationRamp(stepper,t_accel,v_start,accel);

    // --- VELOCIDAD CONSTANTE ---
    if (steps_const >= 1.0f) {
        int steps_to_send = (int)steps_const;
        enqueueMovement(stepper, steps_to_send, v_max);
    }

    // --- DECELERACIÓN SUAVIZADA ---
    steps =+ generateSmoothAccelerationRamp(stepper,t_decel,v_max,-accel);
    printf("Pasos perdios: %d\n", steps);
}


void generateMotionProfile(STEPPER_DRV *stepper, int total_steps, float v_start, float v_max, float v_end, float accel, bool use_s_curve) {
    
        if (use_s_curve) {
            generateSmoothSProfile(stepper,total_steps,v_start,v_max, v_end,accel);
        } else {
            generateTrapezoidalProfile(stepper,total_steps,v_start,v_max, v_end,accel);
        }  
}
