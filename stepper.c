#include "stepper.h"
#include <math.h>
#include <stdio.h>

#define GROUP_SIZE 10  // Steps per group (adjust as needed)
#define PIO_INTR_SM0_TXNEMPTY 0     // PIO interrupt source for SM0 TX FIFO empty
#define PIO_INTR_IRQ0 8             // PIO interrupt source for 'irq 0' instruction

#define CYCLES_PER_STEP 63.0         // Number of PIO clock cycles per step pulse


STEPPER_DRV *s1, *s2, *s3, *s4;     // Pointers to each stepper motor driver

uint8_t steper_number = 0;         // Counter to assign PIO state machines
uint stm_offset;                   // Offset of the loaded PIO program

bool flag = 0;                     // Used to ensure PIO program is only loaded once


void setupStepper(STEPPER_DRV * stepper, uint8_t enable_pin, uint8_t dir_pin, uint8_t step_pin){
    if(steper_number > 3){
        printf("Error: No available stepper slots\n");
        return;
    }

    // Default configuration
    stepper->StepsToTake = 0;
    stepper->activedir = true;
    stepper->dir = RIGHT;
    stepper->ActiveAngle = 0.0;
    stepper->directionchangeDelayCounter = 0;
    stepper->stm_pio = pio0;
    stepper->stm_sm = steper_number;  // Assign state machine 0–3
    stepper->ENABLE_PIN = enable_pin;
    stepper->DIR_PIN = dir_pin;
    stepper->STEP_PIN = step_pin;
    stepper->FULLSTEP = 800;          // Default step resolution

    // Store pointer to global variable depending on index
    switch (steper_number){
        case 0: s1 = stepper; break;
        case 1: s2 = stepper; break;
        case 2: s3 = stepper; break;
        case 3: s4 = stepper; break;
        default: break;
    }

    steper_number++;                // Increment the SM counter

    setupGPIO(stepper);            // Initialize GPIOs
    setupPIO(stepper);            // Configure the PIO for this motor
}



void setupPIO(STEPPER_DRV * stepper)
{
    if(flag == 0){
        // Load PIO program only once and assign IRQ handler
        stm_offset = pio_add_program(stepper->stm_pio, &stepper_precise_program);
        irq_set_exclusive_handler(PIO0_IRQ_0, pio0_irq0_handler);
        irq_set_enabled(PIO0_IRQ_0, true);

        // Enable PIO interrupt generated by the 'irq 0' instruction
        pio_set_irq0_source_enabled(pio0, PIO_INTR_IRQ0, true);
        flag++;
    }

    printf("Setup IO SM: %d\n ", stepper->stm_sm);

    // Initialize the PIO state machine with program, frequency, pin
    stepper_1_program_init(stepper->stm_pio, stepper->stm_sm, stm_offset, stepper->STEP_PIN, 1000, true);

    // Enable PIO interrupt for this SM
    pio_set_irq0_source_enabled(pio0, (enum pio_interrupt_source)(PIO_INTR_IRQ0 + stepper->stm_sm), true);
}




void setupGPIO(STEPPER_DRV * stepper)
{

    // stepper enable pin
    gpio_init(stepper->ENABLE_PIN);
    gpio_set_dir(stepper->ENABLE_PIN, GPIO_OUT);

    // stepper STEP pin
    gpio_init(stepper->STEP_PIN);
    gpio_set_dir(stepper->STEP_PIN, GPIO_OUT);

    // stepperMotor1 dir pin
    gpio_init(stepper->DIR_PIN);
    gpio_set_dir(stepper->DIR_PIN, GPIO_OUT);
    // gpio_put(stepperMotor1.DIR_PIN, 1);

}

// Handler de interrupción para pio0
void pio0_irq0_handler() {
    
     uint32_t irq_status = pio0->irq;         // Read active IRQ flags
    pio_interrupt_clear(pio0, 0);            // Clear IRQ0 so we can trigger it again

    printf("%b\n", irq_status);
    // Check which state machine caused the interrupt
    if (irq_status & (1 << 0)) {
        printf("Interrupción de SM0\n");
        startNextMove(s1);
    }
    if (irq_status & (1 << 1)) {
        printf("Interrupción de SM1\n");
        startNextMove(s2);
    }
    if (irq_status & (1 << 2)) {
        printf("Interrupción de SM2\n");
        startNextMove(s3);
    }
    if (irq_status & (1 << 3)) {
        printf("Interrupción de SM3\n");
        startNextMove(s4);
    }
   

    pio0->irq = irq_status;  // Clear any remaining bits
    printf("Stepper done!\n");
    
}


void setFrec( STEPPER_DRV * stepper, float desired_freq){
    float new_div = clock_get_hz(clk_sys) / (desired_freq*CYCLES_PER_STEP);
    pio_sm_set_clkdiv(stepper->stm_pio, stepper->stm_sm , new_div);
}

void setDirection( STEPPER_DRV * stepper,int direction){
    switch (direction)
    {
    case -1:
        stepper->dir = LEFT;
        gpio_put(stepper->DIR_PIN, false);
        break;
    case 1:
        stepper->dir = RIGHT;
        gpio_put(stepper->DIR_PIN, true);
        break;
    default:
     printf("DIRECTION ERROR\n");
        break;
    }
}

void moveSteps(STEPPER_DRV * stepper, int steps ){
    if(steps == 0){
        printf("STEPS MUST BE DIFFERENT THAN ZERO\n");
        return;
    }

    // Set direction based on sign
    if(steps > 0){
        setDirection(stepper, RIGHT);
    } else {
        setDirection(stepper, LEFT);
    }

    // Enable stepper driver
    gpio_put(stepper->ENABLE_PIN, false);

    // Send number of steps to PIO
    pio_sm_put_blocking(stepper->stm_pio, stepper->stm_sm , abs(steps));
}



void moveStepsAtSpeed(STEPPER_DRV * stepper, int steps, float frec){
    setFrec(stepper, frec);
    moveSteps(stepper, steps);
}

void enqueueMovement(STEPPER_DRV* stepper, int steps, int freq) {
    if (stepper->buffer_length >= BUFFER_SIZE) {
        printf("Buffer full for SM%d\n", stepper->stm_sm);
        return;
    }

    int i = stepper->buffer_tail;

    stepper->buffer[0][i] = steps;
    stepper->buffer[1][i] = freq;

    stepper->buffer_tail = (stepper->buffer_tail + 1) % BUFFER_SIZE;
    stepper->buffer_length++;

    // If stepper is idle, start moving immediately
    if (!stepper->running) {
        stepper->running = true;
        startNextMove(stepper);
    }
}


void startNextMove(STEPPER_DRV* stepper) {
       if (stepper->buffer_length == 0) {
        stepper->running = false;
        printf("END\n");
        return;
    }

    int i = stepper->buffer_head;
    printf("Queue number: %d\n", i);
    int steps = stepper->buffer[0][i];
    int freq  = stepper->buffer[1][i];

    moveStepsAtSpeed(stepper, steps, freq);

    stepper->buffer_head ++;
    if(stepper->buffer_head  >= BUFFER_SIZE){
        stepper->buffer_head  = 0;
    }
    
    stepper->buffer_length--;
}


void calculateAccelTrajectory(STEPPER_DRV *stepper, float target_freq, float accel) {
    float current_speed = stepper->actual_speed;

    // Compute time needed to accelerate from current_speed to target_freq
    float tf = (target_freq - current_speed) / accel;  // seconds
    printf("Total acceleration time (tf): %f s\n", tf);

    // Compute total steps during acceleration using kinematic equation:
    // s = 0.5 * a * t^2 + v0 * t
    float total_steps = 0.5f * accel * tf * tf + current_speed * tf;
    printf("Estimated steps during acceleration: %f steps\n", total_steps);

    // Simulate motion profile (one data point per millisecond for example)
    for (int t_ms = 0; t_ms < (int)(tf * 1000); t_ms++) {
        float t = t_ms / 1000.0f;  // convert ms to seconds

        // Compute instantaneous speed and position at time t
        float speed = accel * t + current_speed;  // in Hz
        float position = 0.5f * accel * t * t + current_speed * t;  // in steps

        printf("Time: %d ms, Position: %f steps, Speed: %f Hz\n", t_ms, position, speed);
    }
}

void enqueueAccelTrajectory(STEPPER_DRV *stepper, float target_freq, float accel, int interval_ms) {
    float current_speed = stepper->actual_speed;
    float tf = (target_freq - current_speed) / accel;
    int intervals = (int)(tf * 1000.0f / interval_ms); // number of chunks
    float t = 0.0f;
    float last_position = 0.0f;

    for (int i = 0; i <= intervals; i++) {
        t = i * (interval_ms / 1000.0f);  // time in seconds

        float position = 0.5f * accel * t * t + current_speed * t;
        float delta_steps = position - last_position;
        last_position = position;

        float speed = accel * t + current_speed;

        int steps = (int)(delta_steps + 0.5f); // round to nearest int
        if (steps != 0) {
            //enqueueMovement(stepper, steps, speed);
            printf("index: %d , Position: %d steps, Speed: %f \n", i, steps, 1000.0);
        }
    }

    // Update the current speed at the end of trajectory
    stepper->actual_speed = target_freq;
}


// Generates a trapezoidal velocity profile for a stepper motor movement
// total_steps: total number of steps to move
// v_start: initial velocity in steps/s
// v_max: maximum velocity in steps/s
// v_end: final velocity in steps/s
// accel: acceleration (and deceleration) in steps/s^2
#define INITIAL_SINGLE_STEPS 10     // Enviar los 3 primeros pasos individualmente
#define INTERVAL_MS 1
#define MIN_GROUP_STEPS 10
#define MIN_FREQ 40.0f              // Frecuencia mínima de seguridad
#define MAX_WAIT_FIRST_SEND_MS 30  // Si pasa demasiado tiempo, forzar envío

float accumulated_steps = 0.0f;
int step_counter = 0;
int accumulated_time_ms = 0;

void generateTrapezoidalProfile(STEPPER_DRV *stepper, int total_steps, float v_start, float v_max, float v_end, float accel) {
    // --- Compute acceleration and deceleration times and step counts ---
    // Tiempo y pasos durante la aceleración
    float t_accel      = (v_max - v_start) / accel;                          // Tiempo para acelerar de v_start a v_max
    float steps_accel  = 0.5f * (v_start + v_max) * t_accel;                // Área bajo la curva de aceleración (trapezoide)

    // Tiempo y pasos durante la deceleración
    float t_decel      = (v_max - v_end) / accel;                            // Tiempo para desacelerar de v_max a v_end
    float steps_decel  = 0.5f * (v_max + v_end) * t_decel;                  // Área bajo la curva de deceleración

    // Pasos y tiempo a velocidad constante
    float steps_const  = total_steps - steps_accel - steps_decel;          // Resto de pasos a velocidad constante
    float t_const = 0.0f;
    if (steps_const > 0.0f) {
        t_const = steps_const / v_max;
    }

    // Tiempo total del perfil
    float total_time   = t_accel + t_const + t_decel;
        printf("Accel: %.1f steps | Const: %.1f steps | Decel: %.1f steps | Total Time: %.3f s\n", steps_accel, steps_const, steps_decel, total_time);

        // --- Handle triangular profile case (not implemented yet) ---
        if (steps_const < 0) {
            printf("Triangular profile required but not implemented.\n");
            return;
        }

        // --- ACCELERATION PHASE ---
    float accumulated_steps = 0.0f;
    float accumulated_time_ms = 0.0f;

    for (int i = 0; i < t_accel * 1000; i += INTERVAL_MS) {
        float t = i / 1000.0f;
        float freq = v_start + accel * t;
        if (freq < MIN_FREQ) freq = MIN_FREQ;

        float delta_steps = freq * (INTERVAL_MS / 1000.0f);
        accumulated_steps += delta_steps;
        accumulated_time_ms += INTERVAL_MS;

        if (accumulated_steps >= MIN_GROUP_STEPS) {
            int steps_to_send = (int)accumulated_steps;
            float avg_freq = accumulated_steps / (accumulated_time_ms / 1000.0f);
            if (avg_freq < MIN_FREQ) avg_freq = MIN_FREQ;
            enqueueMovement(stepper, steps_to_send, avg_freq);
            accumulated_steps -= steps_to_send;
            accumulated_time_ms = 0;
        }
    }

        // --- CONSTANT SPEED PHASE ---
        if (steps_const >= 1.0f) {
            int steps_to_send = (int)steps_const;
            enqueueMovement(stepper, steps_to_send, v_max);
        }

        // --- DECELERATION PHASE ---
        accumulated_steps = 0.0f;
        for (int i = 0; i < t_decel * 1000; i += INTERVAL_MS) {
            float t = i / 1000.0f;
            float freq = v_max - accel * t;

            float delta_steps = freq * (INTERVAL_MS / 1000.0f);;
            accumulated_steps += delta_steps;
    
            if (accumulated_steps >= MIN_GROUP_STEPS) {
                int steps_to_send = (int)accumulated_steps;
                enqueueMovement(stepper, steps_to_send, freq);
                accumulated_steps -= steps_to_send;
            }
        }
}
